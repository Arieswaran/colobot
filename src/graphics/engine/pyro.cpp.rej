diff a/src/graphics/engine/pyro.cpp b/src/graphics/engine/pyro.cpp	(rejected hunks)
@@ -22,8 +22,8 @@
 #include "object.h"
 #include "motion.h"
 #include "motionhuman.h"
-#include "displaytext.h"
 #include "sound.h"
+#include "displaytext.h"
 #include "pyro.h"
 
 
@@ -46,6 +46,7 @@ CPyro::CPyro(CInstanceManager* iMan)
    m_sound       = (CSound*)m_iMan->SearchInstance(CLASS_SOUND);
    m_object = 0;
 
+   m_impact = D3DVECTOR(NAN, NAN, NAN);
    m_progress = 0.0f;
    m_speed = 0.0f;
    m_lightRank = -1;
@@ -73,28 +74,38 @@ void CPyro::DeleteObject(BOOL bAll)
 }
 
 
+// Détermine le point d'impact.
+
+void CPyro::SetImpact(D3DVECTOR impact)
+{
+   m_impact = impact;
+}
+
 // Crée un effet pyrotechnique.
 
-BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
+BOOL CPyro::Create(PyroType type, CObject* pObj, float force, int param)
 {
    D3DMATRIX*      mat;
-   CObject*        power;
    CMotion*        motion;
-   D3DVECTOR       min, max, pos, speed;
+   D3DVECTOR       min, max, pos, speed, p1, p2, p3, p4;
    FPOINT          dim;
    ObjectType      oType;
+   ParticuleType   pType;
    Sound           sound;
    float           duration, mass, h, limit;
    int             part, objRank, total, i, channel;
 
    m_object = pObj;
+   m_posStart = pObj->RetPosition(0);
+   m_angleStart = pObj->RetAngle(0);
    m_force = force;
+   m_param = param;
 
    oType = pObj->RetType();
    objRank = pObj->RetObjectRank(0);
    if ( objRank == -1 )  return FALSE;
    m_engine->GetBBox(objRank, min, max);
-   pos = pObj->RetPosition(0);
+   pos = m_posStart;
 
    DisplayError(type, pObj);  // affiche message éventuel
 
@@ -106,26 +117,26 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
    m_crashSphereUsed = i;
 
    // Calcule la dimension de l'effet.
-   if ( oType == OBJECT_ANT    ||
-        oType == OBJECT_BEE    ||
-        oType == OBJECT_WORM   ||
-        oType == OBJECT_SPIDER )
+   m_size = Length(min, max)*2.0f;
+   if ( m_size <  4.0f )  m_size =  4.0f;
+   if ( m_size > 80.0f )  m_size = 80.0f;
+
+   if ( oType == OBJECT_TNT  ||
+        oType == OBJECT_MINE ||
+        oType == OBJECT_BOMB )
    {
-       m_size = 40.0f;
+       m_size *= 2.0f;
    }
-   else
+
+   if ( m_impact.x == NAN )
    {
-       m_size = Length(min, max)*2.0f;
-       if ( m_size <  4.0f )  m_size =  4.0f;
-       if ( m_size > 80.0f )  m_size = 80.0f;
+       m_pos = pos+(min+max)/2.0f;
    }
-   if ( oType == OBJECT_TNT  ||
-        oType == OBJECT_BOMB )
+   else
    {
-       m_size *= 2.0f;
+       m_pos = m_impact;
    }
 
-   m_pos = pos+(min+max)/2.0f;
    m_type = type;
    m_progress = 0.0f;
    m_speed = 1.0f/20.0f;
@@ -134,75 +145,98 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
    m_lastParticuleSmoke = 0.0f;
    m_lightRank = -1;
 
-   if ( oType == OBJECT_TEEN28 ||
-        oType == OBJECT_TEEN31 )
+   // Cherche s'il faut générer les traînées.
+   m_bTracks = FALSE;
+   m_posTracks = m_pos;
+
+   if ( type == PT_EXPLOS ||
+        type == PT_EXPLOP )
    {
-       m_pos.y = pos.y+1.0f;
+       m_bTracks = TRUE;
    }
-
-   // Cherche la position de la pile.
-   power = pObj->RetPower();
-   if ( power == 0 )
+   if ( type == PT_EXPLOO )
    {
-       m_bPower = FALSE;
+       m_terrain->MoveOnFloor(m_pos);
+       m_pos.y += 0.2f;
+       m_speed = 1.0f/5.0f;
    }
-   else
+   if ( oType == OBJECT_BARREL   ||
+        oType == OBJECT_BARRELa  ||
+        oType == OBJECT_ATOMIC   ||
+        oType == OBJECT_URANIUM  ||
+        oType == OBJECT_TNT      ||
+        oType == OBJECT_MINE     ||
+        oType == OBJECT_BOMB     )
    {
-       m_bPower = TRUE;
-       pos = power->RetPosition(0);
-       pos.y += 1.0f;
-       mat = pObj->RetWorldMatrix(0);
-       m_posPower = Transform(*mat, pos);
+       m_bTracks = TRUE;
+       m_posTracks = m_pos;
+       m_posTracks.y += 1.0f;
+       m_pos = m_posTracks;
    }
-   if ( oType == OBJECT_POWER   ||
-        oType == OBJECT_ATOMIC  ||
-        oType == OBJECT_URANIUM ||
-        oType == OBJECT_TNT     ||
-        oType == OBJECT_BOMB    )
+   if ( oType >= OBJECT_BOX1  &&
+        oType <= OBJECT_BOX10 )
    {
-       m_bPower = TRUE;
-       m_posPower = m_pos;
-       m_posPower.y += 1.0f;
-       m_pos = m_posPower;
+       m_bTracks = TRUE;
+       m_posTracks = m_pos;
+       m_posTracks.y += 1.0f;
+       m_pos = m_posTracks;
    }
-   if ( oType == OBJECT_STATION )
+   if ( oType == OBJECT_NUCLEAR )
    {
-       m_bPower = TRUE;
-       mat = pObj->RetWorldMatrix(0);
-       m_posPower = Transform(*mat, D3DVECTOR(-15.0f, 7.0f, 0.0f));
-       m_pos = m_posPower;
+       m_bTracks = TRUE;
    }
-   if ( oType == OBJECT_ENERGY )
+   if ( oType == OBJECT_PARA )
    {
-       m_bPower = TRUE;
-       mat = pObj->RetWorldMatrix(0);
-       m_posPower = Transform(*mat, D3DVECTOR(-7.0f, 6.0f, 0.0f));
-       m_pos = m_posPower;
+       m_bTracks = TRUE;
    }
-   if ( oType == OBJECT_NUCLEAR )
+   if ( oType == OBJECT_TRAX )
    {
-       m_bPower = TRUE;
-       m_posPower = m_pos;
+       m_bTracks = TRUE;
    }
-   if ( oType == OBJECT_PARA )
+
+   // Cherche s'il faut générer la sphère.
+   m_bSphere = FALSE;
+
+   if ( m_type == PT_FRAGT  ||
+        m_type == PT_EXPLOT ||
+        m_type == PT_EXPLOS )
    {
-       m_bPower = TRUE;
-       m_posPower = m_pos;
+       if ( m_size > 30.0f )
+       {
+           m_bSphere = TRUE;
+       }
    }
-   if ( oType == OBJECT_SCRAP4 ||
-        oType == OBJECT_SCRAP5 )  // matière plastique ?
+
+   // Cherche s'il faut générer l'onde de choc.
+   m_bChoc = FALSE;
+
+   if ( type == PT_FRAGT  ||
+        type == PT_FRAGW  ||
+        type == PT_EXPLOT ||
+        type == PT_EXPLOS ||
+        type == PT_EXPLOW )
    {
-       m_bPower = TRUE;
-       m_posPower = m_pos;
+       if ( m_size > 10.0f || m_bTracks )
+       {
+           m_bChoc = TRUE;
+       }
+       if ( oType >= OBJECT_BOX1 && oType <= OBJECT_BOX10 )
+       {
+           m_bChoc = FALSE;
+       }
    }
 
    // Fait entendre le bruit de l'effet pyrotechnique.
    if ( type == PT_FRAGT  ||
+        type == PT_FRAGA  ||
         type == PT_FRAGW  ||
         type == PT_EXPLOT ||
+        type == PT_EXPLOS ||
         type == PT_EXPLOW )
    {
-       if ( m_bPower )
+       m_main->IncDecorStamp();  // un objet sera détruit
+
+       if ( m_bTracks )
        {
            sound = SOUND_EXPLOp;
        }
@@ -212,34 +246,46 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        }
        if ( oType == OBJECT_STONE   ||
             oType == OBJECT_METAL   ||
-            oType == OBJECT_BULLET  ||
             oType == OBJECT_BBOX    ||
             oType == OBJECT_KEYa    ||
             oType == OBJECT_KEYb    ||
             oType == OBJECT_KEYc    ||
-            oType == OBJECT_KEYd    )
+            oType == OBJECT_KEYd    ||
+            (oType >= OBJECT_ROADSIGN1 && oType <= OBJECT_ROADSIGN30) )
        {
            sound = SOUND_EXPLOl;
        }
-       if ( oType == OBJECT_URANIUM ||
-            oType == OBJECT_POWER   ||
-            oType == OBJECT_ATOMIC  ||
-            oType == OBJECT_TNT     ||
-            oType == OBJECT_BOMB    )
+       if ( oType == OBJECT_URANIUM  ||
+            oType == OBJECT_BARREL   ||
+            oType == OBJECT_BARRELa  ||
+            oType == OBJECT_ATOMIC   ||
+            oType == OBJECT_TNT      ||
+            oType == OBJECT_MINE     ||
+            oType == OBJECT_BOMB     ||
+            (oType >= OBJECT_BOX1 && oType <= OBJECT_BOX10) )
        {
            sound = SOUND_EXPLOlp;
        }
        m_sound->Play(sound, m_pos);
    }
-   if ( type == PT_FRAGO  ||
-        type == PT_EXPLOO ||
-        type == PT_SPIDER ||
-        type == PT_SHOTM  )
+   if ( type == PT_EXPLOO )
    {
        m_sound->Play(SOUND_EXPLOi, m_pos);
    }
+   if ( type == PT_FRAGO )
+   {
+       m_sound->Play(SOUND_EXPLOlp, m_pos);
+   }
+   if ( type == PT_EJECT )
+   {
+       if ( oType >= OBJECT_CARCASS1 && oType <= OBJECT_CARCASS10 )
+       {
+           m_sound->Play(SOUND_BOUMm, m_pos);
+       }
+   }
    if ( type == PT_BURNT ||
-        type == PT_BURNO )
+        type == PT_BURNO ||
+        type == PT_BURNS )
    {
        m_soundChannel = m_sound->Play(SOUND_BURN, m_pos, 1.0f, 1.0f, TRUE);
        m_sound->AddEnvelope(m_soundChannel, 1.0f, 1.0f, 12.0f, SOPER_CONTINUE);
@@ -247,37 +293,51 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
    }
    if ( type == PT_BURNO )
    {
-       m_sound->Play(SOUND_DEADi, m_pos);
-       m_sound->Play(SOUND_DEADi, m_engine->RetEyePt());
-   }
-   if ( type == PT_EGG )
-   {
-       m_sound->Play(SOUND_EGG, m_pos);
+       m_sound->Play(SOUND_EVIL1, m_pos, 1.0f, 0.5f);
    }
-   if ( type == PT_WPCHECK  ||
-        type == PT_FLCREATE ||
+   if ( type == PT_FLCREATE ||
         type == PT_FLDELETE )
    {
        m_sound->Play(SOUND_WAYPOINT, m_pos);
    }
-   if ( oType == OBJECT_HUMAN )
+
+   if ( type == PT_FRAGT  ||
+        type == PT_FRAGW  ||
+        type == PT_EXPLOT ||
+        type == PT_EXPLOS ||
+        type == PT_EXPLOW )
    {
-       if ( type == PT_DEADG )
-       {
-           m_sound->Play(SOUND_DEADg, m_pos);
-       }
-       if ( type == PT_DEADW )
-       {
-           m_sound->Play(SOUND_DEADw, m_pos);
-       }
-       if ( type == PT_SHOTH && m_object->RetSelect() )
-       {
-           m_sound->Play(SOUND_AIE, m_pos);
-           m_sound->Play(SOUND_AIE, m_engine->RetEyePt());
-       }
+       // Crée une tache au sol.
+       p1 = p2 = p3 = p4 = m_pos;
+       p1.x -= 8.0f;  p1.z += 8.0f;
+       p2.x += 8.0f;  p2.z += 8.0f;
+       p3.x -= 8.0f;  p3.z -= 8.0f;
+       p4.x += 8.0f;  p4.z -= 8.0f;
+       m_particule->CreateWheelTrace(p1, p2, p3, p4, PARTITRACE3);
+   }
+   if ( type == PT_FRAGA )
+   {
+       // Crée une tache au sol.
+       p1 = p2 = p3 = p4 = m_pos;
+       p1.x -= 24.0f;  p1.z += 24.0f;
+       p2.x += 24.0f;  p2.z += 24.0f;
+       p3.x -= 24.0f;  p3.z -= 24.0f;
+       p4.x += 24.0f;  p4.z -= 24.0f;
+       m_particule->CreateWheelTrace(p1, p2, p3, p4, PARTITRACE5);
+   }
+   if ( type == PT_EXPLOO )
+   {
+       // Crée une tache au sol.
+       p1 = p2 = p3 = p4 = m_pos;
+       p1.x -= 24.0f;  p1.z += 24.0f;
+       p2.x += 24.0f;  p2.z += 24.0f;
+       p3.x -= 24.0f;  p3.z -= 24.0f;
+       p4.x += 24.0f;  p4.z -= 24.0f;
+       m_particule->CreateWheelTrace(p1, p2, p3, p4, PARTITRACE8);
    }
 
    if ( m_type == PT_FRAGT ||
+        m_type == PT_FRAGA ||
         m_type == PT_FRAGO ||
         m_type == PT_FRAGW )
    {
@@ -329,22 +389,31 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        m_speed = 1.0f/0.2f;
        return TRUE;
    }
+   if ( m_type == PT_EXPLOO )
+   {
+       m_camera->StartOver(OE_ORGA, m_pos, 1.0f);
+   }
 
    if ( m_type == PT_SHOTW )
    {
        m_speed = 1.0f/1.0f;
    }
 
-   if ( m_type == PT_BURNT )
+   if ( m_type == PT_BURNT ||
+        m_type == PT_BURNO )
    {
        BurnStart();
    }
 
    if ( m_type == PT_WPCHECK )
    {
-       m_speed = 1.0f/8.0f;
+       m_speed = 1.0f/4.0f;
        m_object->SetEnable(FALSE);  // objet plus fonctionnel
    }
+   if ( m_type == PT_WPVIBRA )
+   {
+       m_speed = 1.0f/4.0f;
+   }
    if ( m_type == PT_FLCREATE )
    {
        m_speed = 1.0f/2.0f;
@@ -354,45 +423,51 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        m_speed = 1.0f/2.0f;
        m_object->SetEnable(FALSE);  // objet plus fonctionnel
    }
-   if ( m_type == PT_RESET )
-   {
-       m_speed = 1.0f/2.0f;
-       m_object->SetPosition(0, m_object->RetResetPosition());
-       m_object->SetAngle(0, m_object->RetResetAngle());
-       m_object->SetZoom(0, 0.0f);
-   }
    if ( m_type == PT_FINDING )
    {
        limit = (m_size-1.0f)/4.0f;
        if ( limit > 8.0f )  limit = 8.0f;
-       if ( oType == OBJECT_APOLLO2 )  limit = 2.0f;
+       m_speed = 1.0f/limit;
+   }
+   if ( m_type == PT_PAINTING )
+   {
+       limit = (m_size-1.0f)/8.0f;
+       if ( limit > 4.0f )  limit = 4.0f;
        m_speed = 1.0f/limit;
    }
 
    if ( m_type == PT_EXPLOT ||
-        m_type == PT_EXPLOO ||
-        m_type == PT_EXPLOW )
+        m_type == PT_EXPLOW ||
+        m_type == PT_EJECT  )
    {
        CreateTriangle(pObj, oType, 0);
        m_engine->ShadowDelete(m_object->RetObjectRank(0));
-       ExploStart();
+       ExploStart(oType);
    }
 
-   if ( m_type == PT_FALL )
+   if ( m_type == PT_EXPLOO )
    {
-       FallStart();
-       return TRUE;
+       m_engine->ShadowDelete(m_object->RetObjectRank(0));
+       OrgaStart();
+   }
+
+   if ( m_type == PT_ACROBATIC ||
+        m_type == PT_SABOTAGE  ||
+        m_type == PT_PIECE     )
+   {
+       AcrobaticStart(min, max);
    }
 
    if ( m_type == PT_BURNT ||
-        m_type == PT_BURNO )
+        m_type == PT_BURNO ||
+        m_type == PT_BURNS )
    {
        m_speed = 1.0f/15.0f;
 
        LightOperAdd(0.00f, 0.0f,  2.0f,  1.0f,  0.0f);  // rouge-orange
-       LightOperAdd(0.30f, 1.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-       LightOperAdd(0.80f, 1.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-       LightOperAdd(1.00f, 0.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
+       LightOperAdd(0.30f, 1.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+       LightOperAdd(0.80f, 1.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+       LightOperAdd(1.00f, 0.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
        CreateLight(m_pos, 40.0f);
        return TRUE;
    }
@@ -408,26 +483,41 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        m_engine->ShadowDelete(m_object->RetObjectRank(0));
    }
 
-   if ( m_type != PT_EGG  &&
-        m_type != PT_WIN  &&
-        m_type != PT_LOST )
+   // Génère les effets de lumière.
+   if ( m_type != PT_EGG       &&
+        m_type != PT_WIN       &&
+        m_type != PT_LOST      &&
+        m_type != PT_EJECT     &&
+        m_type != PT_EXPLOP    &&
+        m_type != PT_SABOTAGE  &&
+        m_type != PT_ACROBATIC &&
+        m_type != PT_PIECE     )
    {
        h = 40.0f;
        if ( m_type == PT_FRAGO  ||
             m_type == PT_EXPLOO )
        {
-           LightOperAdd(0.00f, 0.0f, -1.0f, -0.5f, -1.0f);  // vert foncé
-           LightOperAdd(0.05f, 1.0f, -1.0f, -0.5f, -1.0f);  // vert foncé
-           LightOperAdd(1.00f, 0.0f, -1.0f, -0.5f, -1.0f);  // vert foncé
+           LightOperAdd(0.00f, 0.0f,  4.0f,  4.0f,  4.0f);  // blanc
+           LightOperAdd(0.05f, 1.0f, -1.0f,  4.0f, -1.0f);  // vert clair
+           LightOperAdd(1.00f, 0.0f, -1.0f,  4.0f, -1.0f);  // vert clair
+           h = m_size*10.0f;
        }
        else if ( m_type == PT_FRAGT  ||
-                 m_type == PT_EXPLOT )
+                 m_type == PT_EXPLOT ||
+                 m_type == PT_EXPLOS )
        {
            LightOperAdd(0.00f, 1.0f,  4.0f,  4.0f,  2.0f);  // jaune
            LightOperAdd(0.02f, 1.0f,  4.0f,  2.0f,  0.0f);  // rouge-orange
-           LightOperAdd(0.16f, 1.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-           LightOperAdd(1.00f, 0.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-           h = m_size*2.0f;
+           LightOperAdd(0.16f, 1.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+           LightOperAdd(1.00f, 0.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+           h = m_size*5.0f;
+       }
+       else if ( m_type == PT_FRAGA )
+       {
+           LightOperAdd(0.00f, 1.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+           LightOperAdd(0.05f, 1.0f, -2.0f,  4.0f,  4.0f);  // bleu
+           LightOperAdd(1.00f, 0.0f, -2.0f,  4.0f,  4.0f);  // bleu
+           h = m_size*10.0f;
        }
        else if ( m_type == PT_SPIDER )
        {
@@ -444,28 +534,30 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
            LightOperAdd(1.00f, 0.0f, -0.5f, -0.5f, -1.0f);  // jaune foncé
        }
        else if ( m_type == PT_WPCHECK  ||
+                 m_type == PT_WPVIBRA  ||
                  m_type == PT_FLCREATE ||
                  m_type == PT_FLDELETE ||
-                 m_type == PT_RESET    ||
-                 m_type == PT_FINDING  )
+                 m_type == PT_FINDING  ||
+                 m_type == PT_PAINTING )
        {
            LightOperAdd(0.00f, 1.0f,  4.0f,  4.0f,  2.0f);  // jaune
            LightOperAdd(1.00f, 0.0f,  4.0f,  4.0f,  2.0f);  // jaune
        }
        else
        {
-           LightOperAdd(0.00f, 0.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-           LightOperAdd(0.05f, 1.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
-           LightOperAdd(1.00f, 0.0f, -0.8f, -0.8f, -0.8f);  // gris foncé
+           LightOperAdd(0.00f, 0.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+           LightOperAdd(0.05f, 1.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
+           LightOperAdd(1.00f, 0.0f, -0.4f, -0.4f, -0.4f);  // gris foncé
        }
        CreateLight(m_pos, h);
 
        if ( m_type != PT_SHOTW    &&
             m_type != PT_WPCHECK  &&
+            m_type != PT_WPVIBRA  &&
             m_type != PT_FLCREATE &&
             m_type != PT_FLDELETE &&
-            m_type != PT_RESET    &&
-            m_type != PT_FINDING  )
+            m_type != PT_FINDING  &&
+            m_type != PT_PAINTING )
        {
            m_camera->StartEffect(CE_EXPLO, m_pos, force);
        }
@@ -475,13 +567,11 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
    
    // Génère les triangles de l'explosion.
    if ( m_type == PT_FRAGT  ||
+        m_type == PT_FRAGA  ||
         m_type == PT_FRAGO  ||
         m_type == PT_FRAGW  ||
         m_type == PT_SPIDER ||
-        m_type == PT_EGG    ||
-       (m_type == PT_EXPLOT && oType == OBJECT_MOBILEtg) ||
-       (m_type == PT_EXPLOT && oType == OBJECT_TEEN28  ) ||
-       (m_type == PT_EXPLOT && oType == OBJECT_TEEN31  ) )
+        m_type == PT_EGG    )
    {
        for ( part=0 ; part<OBJECTMAXPART ; part++ )
        {
@@ -489,17 +579,22 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        }
    }
 
-   if ( m_type == PT_FRAGT  ||
-        m_type == PT_EXPLOT )
+   // Génère les particules avec traînées.
+   if ( m_bTracks )
    {
-       if ( m_bPower )
+       if ( m_type == PT_FRAGT  ||
+            m_type == PT_FRAGA  ||
+            m_type == PT_EXPLOT ||
+            m_type == PT_EXPLOS )
        {
            total = (int)(10.0f*m_engine->RetParticuleDensity());
            if ( oType == OBJECT_TNT  ||
-                oType == OBJECT_BOMB )  total *= 3;
+                oType == OBJECT_MINE ||
+                oType == OBJECT_BOMB ||
+                oType == OBJECT_TRAX )  total *= 3;
            for ( i=0 ; i<total ; i++ )
            {
-               pos = m_posPower;
+               pos = m_posTracks;
                speed.x = (Rand()-0.5f)*30.0f;
                speed.z = (Rand()-0.5f)*30.0f;
                speed.y = Rand()*30.0f;
@@ -507,57 +602,99 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
                dim.y = dim.x;
                duration = Rand()*3.0f+2.0f;
                mass = Rand()*10.0f+15.0f;
-               m_particule->CreateTrack(pos, speed, dim, PARTITRACK1,
+               if ( oType >= OBJECT_BOX1 && oType <= OBJECT_BOX10 )
+               {
+                   pType = (ParticuleType)(PARTITRACK1+rand()%4);
+               }
+               else if ( m_type == PT_FRAGA )
+               {
+                   pType = PARTITRACK2;  // bleu
+               }
+               else
+               {
+                   pType = PARTITRACK1;  // orange
+               }
+               m_particule->CreateTrack(pos, speed, dim, pType,
                                         duration, mass, Rand()+0.7f, 1.0f);
            }
        }
-
-       if ( m_size > 10.0f )  // assez grand (fret exclu) ?
+       if ( m_type == PT_EXPLOP )
        {
-           if ( m_bPower )
-           {
-               pos = m_posPower;
-           }
-           else
+           total = (int)(10.0f*m_engine->RetParticuleDensity());
+           for ( i=0 ; i<total ; i++ )
            {
-               pos = m_pos;
-               m_terrain->MoveOnFloor(pos);
-               pos.y += 1.0f;
+               pos = m_posTracks;
+               speed.x = (Rand()-0.5f)*60.0f;
+               speed.z = (Rand()-0.5f)*60.0f;
+               speed.y = Rand()*30.0f;
+               dim.x = 0.5f;
+               dim.y = dim.x;
+               duration = Rand()*0.2f+0.2f;
+               mass = Rand()*5.0f+5.0f;
+               m_particule->CreateTrack(pos, speed, dim, PARTITRACK1,
+                                        duration, mass, 10.0f);
            }
-           dim.x = m_size*0.4f;
-           dim.y = dim.x;
-           m_particule->CreateParticule(pos, D3DVECTOR(0.0f,0.0f,0.0f), dim, PARTISPHERE0, 2.0f, 0.0f, 0.0f);
        }
    }
 
+   // Génère la grosse sphère translucide.
+   if ( m_bSphere )  // sphère ?
+   {
+       if ( m_bTracks )
+       {
+           pos = m_posTracks;
+       }
+       else
+       {
+           pos = m_pos;
+           m_terrain->MoveOnFloor(pos);
+           pos.y += 1.0f;
+       }
+       dim.x = m_size*0.4f;
+       dim.y = dim.x;
+       m_particule->CreateParticule(pos, D3DVECTOR(0.0f,0.0f,0.0f), dim,
+                                    (m_type==PT_FRAGA)?PARTISPHERE3:PARTISPHERE0,
+                                    2.0f, 0.0f);
+   }
+
    if ( m_type == PT_FRAGO  ||
         m_type == PT_EXPLOO )
    {
-       total = (int)(10.0f*m_engine->RetParticuleDensity());
+       pos = m_pos;
+       pos.y += 5.0f;
+       speed = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       dim.x = 8.0f;
+       dim.y = dim.x;
+       duration = 0.3f;
+       m_particule->CreateParticule(pos, speed, dim, PARTIBIGO, duration);
+
+       total = (int)(20.0f*m_engine->RetParticuleDensity());
        for ( i=0 ; i<total ; i++ )
        {
            pos = m_pos;
+           pos.y += 2.0f;
            speed.x = (Rand()-0.5f)*30.0f;
            speed.z = (Rand()-0.5f)*30.0f;
-           speed.y = Rand()*50.0f;
-           dim.x = 1.0f;
+           speed.y = 15.0f+Rand()*15.0f;
+           dim.x = 2.0f;
            dim.y = dim.x;
-           duration = Rand()*1.0f+0.8f;
-           mass = Rand()*10.0f+15.0f;
+           duration = Rand()*1.0f+1.0f;
+           mass = Rand()*30.0f+40.0f;
            m_particule->CreateParticule(pos, speed, dim, PARTIORGANIC1,
                                         duration, mass);
        }
-       total = (int)(5.0f*m_engine->RetParticuleDensity());
+       total = (int)(20.0f*m_engine->RetParticuleDensity());
        for ( i=0 ; i<total ; i++ )
        {
            pos = m_pos;
+           pos.y += 2.0f;
            speed.x = (Rand()-0.5f)*30.0f;
            speed.z = (Rand()-0.5f)*30.0f;
-           speed.y = Rand()*50.0f;
+           speed.y = 15.0f+Rand()*15.0f;
            dim.x = 1.0f;
            dim.y = dim.x;
-           duration = Rand()*2.0f+1.4f;
-           mass = Rand()*10.0f+15.0f;
+           duration = Rand()*1.0f+1.0f;
+           mass = Rand()*30.0f+40.0f;
            m_particule->CreateTrack(pos, speed, dim, PARTITRACK4,
                                     duration, mass, duration*0.5f, dim.x*2.0f);
        }
@@ -596,21 +733,15 @@ BOOL CPyro::Create(PyroType type, CObject* pObj, float force)
        }
    }
 
-   if ( type == PT_FRAGT  ||
-        type == PT_FRAGW  ||
-        type == PT_EXPLOT ||
-        type == PT_EXPLOW )
+   if ( m_bChoc )  // onde de choc circulaire et horizontale ?
    {
-       if ( m_size > 10.0f || m_bPower )
-       {
-           pos = m_pos;
-//?            m_terrain->MoveOnFloor(pos);
-//?            pos.y += 2.0f;
-           speed = D3DVECTOR(0.0f, 0.0f, 0.0f);
-           dim.x = m_size;
-           dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTICHOC, 2.0f);
-       }
+       pos = m_pos;
+//?        m_terrain->MoveOnFloor(pos);
+//?        pos.y += 2.0f;
+       speed = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       dim.x = m_size;
+       dim.y = dim.x;
+       m_particule->CreateParticule(pos, speed, dim, PARTICHOC, 2.0f);
    }
 
    return TRUE;
@@ -626,26 +757,29 @@ void CPyro::CreateTriangle(CObject* pObj, ObjectType oType, int part)
    float           percent, min, max, h, duration, mass;
    int             objRank, total, i;
 
+   if ( oType == OBJECT_CONE )  return;
+
    objRank = pObj->RetObjectRank(part);
    if ( objRank == -1 )  return;
 
    min = 0.0f;
-   max = m_engine->RetLimitLOD(0);
+//?    max = m_engine->RetLimitLOD(0);
+   max = 1000000.0f;
    total = m_engine->RetTotalTriangles(objRank);
    percent = 0.10f;
    if ( total < 50 )  percent = 0.25f;
    if ( total < 20 )  percent = 0.50f;
    if ( m_type == PT_EGG )  percent = 0.30f;
-   if ( oType == OBJECT_POWER    ||
+   if ( oType == OBJECT_BARREL   ||
+        oType == OBJECT_BARRELa  ||
         oType == OBJECT_ATOMIC   ||
         oType == OBJECT_URANIUM  ||
         oType == OBJECT_TNT      ||
+        oType == OBJECT_MINE     ||
         oType == OBJECT_BOMB     )  percent = 0.75f;
    if ( oType == OBJECT_MOBILEtg )  percent = 0.50f;
-   if ( oType == OBJECT_TEEN28   )  percent = 0.75f;
-   if ( oType == OBJECT_MOTHER   )  max = 1000000.0f;
-   if ( oType == OBJECT_TEEN28   )  max = 1000000.0f;
-   if ( oType == OBJECT_TEEN31   )  max = 1000000.0f;
+   if ( oType == OBJECT_MARK     )  percent = 0.75f;
+   if ( oType >= OBJECT_BOX1 && oType <= OBJECT_BOX10 )  percent = 1.00f;
    total = m_engine->GetTriangles(objRank, min, max, buffer, 100, percent);
 
    for ( i=0 ; i<total ; i++ )
@@ -737,9 +871,10 @@ void CPyro::CreateTriangle(CObject* pObj, ObjectType oType, int part)
        }
        if ( oType == OBJECT_STONE   )  speed *= 0.5f;
        if ( oType == OBJECT_URANIUM )  speed *= 0.4f;
+       if ( oType >= OBJECT_CARCASS1 && oType <= OBJECT_CARCASS10 )  speed *= 0.1f;
        duration = Rand()*3.0f+3.0f;
        m_particule->CreateFrag(pos, speed, &buffer[i], PARTIFRAG,
-                               duration, mass, 0.5f);
+                               duration, mass);
    }
 }
 
@@ -748,86 +883,6 @@ void CPyro::CreateTriangle(CObject* pObj, ObjectType oType, int part)
 
 void CPyro::DisplayError(PyroType type, CObject* pObj)
 {
-   ObjectType      oType;
-   Error           err;
-
-   oType = pObj->RetType();
-
-   if ( type == PT_FRAGT  ||
-        type == PT_FRAGO  ||
-        type == PT_FRAGW  ||
-        type == PT_EXPLOT ||
-        type == PT_EXPLOO ||
-        type == PT_EXPLOW ||
-        type == PT_BURNT  ||
-        type == PT_BURNO  )
-   {
-       err = ERR_OK;
-       if ( oType == OBJECT_MOTHER )  err = INFO_DELETEMOTHER;
-       if ( oType == OBJECT_ANT    )  err = INFO_DELETEANT;
-       if ( oType == OBJECT_BEE    )  err = INFO_DELETEBEE;
-       if ( oType == OBJECT_WORM   )  err = INFO_DELETEWORM;
-       if ( oType == OBJECT_SPIDER )  err = INFO_DELETESPIDER;
-
-       if ( oType == OBJECT_MOBILEwa ||
-            oType == OBJECT_MOBILEta ||
-            oType == OBJECT_MOBILEfa ||
-            oType == OBJECT_MOBILEia ||
-            oType == OBJECT_MOBILEwc ||
-            oType == OBJECT_MOBILEtc ||
-            oType == OBJECT_MOBILEfc ||
-            oType == OBJECT_MOBILEic ||
-            oType == OBJECT_MOBILEwi ||
-            oType == OBJECT_MOBILEti ||
-            oType == OBJECT_MOBILEfi ||
-            oType == OBJECT_MOBILEii ||
-            oType == OBJECT_MOBILEws ||
-            oType == OBJECT_MOBILEts ||
-            oType == OBJECT_MOBILEfs ||
-            oType == OBJECT_MOBILEis ||
-            oType == OBJECT_MOBILErt ||
-            oType == OBJECT_MOBILErc ||
-            oType == OBJECT_MOBILErr ||
-            oType == OBJECT_MOBILErs ||
-            oType == OBJECT_MOBILEsa ||
-            oType == OBJECT_MOBILEwt ||
-            oType == OBJECT_MOBILEtt ||
-            oType == OBJECT_MOBILEft ||
-            oType == OBJECT_MOBILEit ||
-            oType == OBJECT_MOBILEdr )
-       {
-           err = ERR_DELETEMOBILE;
-       }
-
-       if ( oType == OBJECT_DERRICK  ||
-            oType == OBJECT_FACTORY  ||
-            oType == OBJECT_STATION  ||
-            oType == OBJECT_CONVERT  ||
-            oType == OBJECT_REPAIR   ||
-            oType == OBJECT_DESTROYER||
-            oType == OBJECT_TOWER    ||
-            oType == OBJECT_RESEARCH ||
-            oType == OBJECT_RADAR    ||
-            oType == OBJECT_INFO     ||
-            oType == OBJECT_ENERGY   ||
-            oType == OBJECT_LABO     ||
-            oType == OBJECT_NUCLEAR  ||
-            oType == OBJECT_PARA     ||
-            oType == OBJECT_SAFE     ||
-            oType == OBJECT_HUSTON   ||
-            oType == OBJECT_START    ||
-            oType == OBJECT_END      )
-       {
-           err = ERR_DELETEBUILDING;
-           m_displayText->DisplayError(err, pObj->RetPosition(0), 5.0f);
-           return;
-       }
-
-       if ( err != ERR_OK )
-       {
-           m_displayText->DisplayError(err, pObj);
-       }
-   }
 }
 
 
@@ -838,7 +893,7 @@ BOOL CPyro::EventProcess(const Event &event)
    ParticuleType   type;
    D3DVECTOR       pos, speed, angle;
    FPOINT          dim;
-   float           prog, factor, duration;
+   float           factor;
    int             i, r;
 
    if ( event.event != EVENT_FRAME )  return TRUE;
@@ -873,7 +928,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.x = (Rand()-0.5f)*m_crashSphereRadius[i]*0.5f;
            speed.z = (Rand()-0.5f)*m_crashSphereRadius[i]*0.5f;
            speed.y = Rand()*m_crashSphereRadius[i]*1.0f;
-           dim.x = Rand()*m_crashSphereRadius[i]*0.5f+m_crashSphereRadius[i]*0.75f*m_force;
+           dim.x = (Rand()*m_crashSphereRadius[i]*0.5f+m_crashSphereRadius[i]*0.75f*m_force)*5.0f;
            dim.y = dim.x;
            m_particule->CreateParticule(pos, speed, dim, PARTISMOKE1, 3.0f);
        }
@@ -895,42 +950,12 @@ BOOL CPyro::EventProcess(const Event &event)
         m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
    {
        m_lastParticule = m_time;
-
-       for ( i=0 ; i<10 ; i++ )
-       {
-           pos = m_pos;
-           pos.x += (Rand()-0.5f)*m_size*0.2f;
-           pos.z += (Rand()-0.5f)*m_size*0.2f;
-           pos.y += (Rand()-0.5f)*m_size*0.5f;
-           speed.x = (Rand()-0.5f)*5.0f;
-           speed.z = (Rand()-0.5f)*5.0f;
-           speed.y = Rand()*1.0f;
-           dim.x = 1.0f;
-           dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIBLOOD, Rand()*3.0f+3.0f, Rand()*10.0f+15.0f, 0.5f);
-       }
    }
 
    if ( m_type == PT_SHOTM &&
         m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
    {
        m_lastParticule = m_time;
-
-       r = (int)(10.0f*m_engine->RetParticuleDensity());
-       for ( i=0 ; i<r ; i++ )
-       {
-           pos = m_pos;
-           pos.x += (Rand()-0.5f)*20.0f;
-           pos.z += (Rand()-0.5f)*20.0f;
-           pos.y += 8.0f;
-           speed.x = (Rand()-0.5f)*40.0f;
-           speed.z = (Rand()-0.5f)*40.0f;
-           speed.y = Rand()*40.0f;
-           dim.x = Rand()*8.0f+8.0f*m_force;
-           dim.y = dim.x;
-
-           m_particule->CreateParticule(pos, speed, dim, PARTIBLOODM, 2.0f, 50.0f, 0.0f);
-       }
    }
 
    if ( m_type == PT_SHOTW &&
@@ -949,7 +974,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = Rand()*m_crashSphereRadius[i]*1.0f;
            dim.x = 1.0f*m_force;
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f, 0.0f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f);
        }
        else
        {
@@ -961,7 +986,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = Rand()*m_size*0.2f;
            dim.x = 1.0f*m_force;
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f, 0.0f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f);
        }
    }
 
@@ -982,7 +1007,9 @@ BOOL CPyro::EventProcess(const Event &event)
        m_particule->CreateParticule(pos, speed, dim, PARTICRASH, 4.0f);
    }
 
-   if ( (m_type == PT_FRAGT || m_type == PT_EXPLOT) &&
+   if ( (m_type == PT_FRAGT  ||
+         m_type == PT_EXPLOT ||
+         m_type == PT_EXPLOS ) &&
         m_progress < 0.05f &&
         m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
    {
@@ -998,7 +1025,25 @@ BOOL CPyro::EventProcess(const Event &event)
        m_particule->CreateParticule(pos, speed, dim, PARTIEXPLOT);
    }
 
-   if ( (m_type == PT_FRAGT || m_type == PT_EXPLOT) &&
+   if ( m_type == PT_FRAGA &&
+        m_progress < 0.05f &&
+        m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
+   {
+       m_lastParticule = m_time;
+
+       pos = m_pos;
+       speed.x = (Rand()-0.5f)*m_size*1.0f;
+       speed.z = (Rand()-0.5f)*m_size*1.0f;
+       speed.y = Rand()*m_size*0.50f;
+       dim.x = Rand()*m_size/5.0f+m_size/5.0f;
+       dim.y = dim.x;
+
+       m_particule->CreateParticule(pos, speed, dim, PARTIEXPLOA);
+   }
+
+   if ( (m_type == PT_FRAGT  ||
+         m_type == PT_EXPLOT ||
+         m_type == PT_EXPLOS ) &&
         m_progress < 0.10f &&
         m_lastParticuleSmoke+m_engine->ParticuleAdapt(0.10f) <= m_time )
    {
@@ -1021,20 +1066,49 @@ BOOL CPyro::EventProcess(const Event &event)
        m_particule->CreateParticule(pos, speed, dim, type, 6.0f);
    }
 
+   if ( m_type == PT_FRAGA &&
+        m_progress < 0.10f &&
+        m_lastParticuleSmoke+m_engine->ParticuleAdapt(0.10f) <= m_time )
+   {
+       m_lastParticuleSmoke = m_time;
+
+       dim.x = Rand()*m_size/1.5f+m_size/1.5f;
+       dim.y = dim.x;
+       pos = m_pos;
+       pos.x += (Rand()-0.5f)*m_size*2.0f;
+       pos.z += (Rand()-0.5f)*m_size*2.0f;
+       m_terrain->MoveOnFloor(pos);
+       speed.x = 0.0f;
+       speed.z = 0.0f;
+       speed.y = -dim.x/2.0f/4.0f;
+       pos.y += dim.x/2.0f;
+       m_particule->CreateParticule(pos, speed, dim, PARTIEJECT, 6.0f);
+   }
+
    if ( (m_type == PT_FRAGO || m_type == PT_EXPLOO) &&
-        m_progress < 0.03f &&
-        m_lastParticule+m_engine->ParticuleAdapt(0.1f) <= m_time )
+        m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
    {
        m_lastParticule = m_time;
 
        pos = m_pos;
-       speed.x = (Rand()-0.5f)*m_size*2.0f;
-       speed.z = (Rand()-0.5f)*m_size*2.0f;
-       speed.y = Rand()*m_size*1.0f;
-       dim.x = Rand()*m_size/2.0f+m_size/2.0f;
+       speed.x = (Rand()-0.5f)*m_size*1.0f;
+       speed.z = (Rand()-0.5f)*m_size*1.0f;
+       speed.y = Rand()*m_size*0.5f;
+       speed *= 1.0f-m_progress;
+       dim.x = (Rand()*m_size/2.0f+m_size/2.0f)*(1.0f-m_progress);
        dim.y = dim.x;
+//?        m_particule->CreateParticule(pos, speed, dim, PARTIEXPLOO);
+   }
+   if ( m_type == PT_EXPLOO )
+   {
+       OrgaProgress();
+   }
 
-       m_particule->CreateParticule(pos, speed, dim, PARTIEXPLOO);
+   if ( m_type == PT_ACROBATIC ||
+        m_type == PT_SABOTAGE  ||
+        m_type == PT_PIECE     )
+   {
+       AcrobaticProgress();
    }
 
    if ( (m_type == PT_FRAGW || m_type == PT_EXPLOW) &&
@@ -1049,8 +1123,7 @@ BOOL CPyro::EventProcess(const Event &event)
        speed.y = Rand()*m_size*0.50f;
        dim.x = 1.0f;
        dim.y = dim.x;
-
-       m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f, 0.0f);
+       m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 0.5f, 0.0f);
    }
 
    if ( (m_type == PT_FRAGW || m_type == PT_EXPLOW) &&
@@ -1089,22 +1162,21 @@ BOOL CPyro::EventProcess(const Event &event)
 
            pos = m_pos;
            pos.y += factor;
-           pos.x += (Rand()-0.5f)*3.0f;
-           pos.z += (Rand()-0.5f)*3.0f;
+           pos.x += (Rand()-0.5f)*9.0f;
+           pos.z += (Rand()-0.5f)*9.0f;
            speed.x = 0.0f;
            speed.z = 0.0f;
            speed.y = 5.0f+Rand()*5.0f;
-           dim.x = Rand()*1.5f+1.5f;
+           dim.x = Rand()*2.0f+2.0f;
            dim.y = dim.x;
            m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f);
-//?            m_particule->CreateParticule(pos, speed, dim, (ParticuleType)(PARTILENS1+rand()%4), 2.0f);
        }
 
-       angle = m_object->RetAngle(0);
+       angle = m_object->RetCirVibration();
        angle.y = m_progress*20.0f;
        angle.x = sinf(m_progress*49.0f)*0.3f;
        angle.z = sinf(m_progress*47.0f)*0.2f;
-       m_object->SetAngle(0, angle);
+       m_object->SetCirVibration(angle);
 
        pos = m_pos;
        pos.y += factor;
@@ -1116,6 +1188,32 @@ BOOL CPyro::EventProcess(const Event &event)
        }
    }
 
+   if ( m_type == PT_WPVIBRA )
+   {
+       if ( m_progress < 0.85f &&
+            m_lastParticule+m_engine->ParticuleAdapt(0.10f) <= m_time )
+       {
+           m_lastParticule = m_time;
+
+           pos = m_pos;
+           pos.x += (Rand()-0.5f)*9.0f;
+           pos.z += (Rand()-0.5f)*9.0f;
+           speed.x = 0.0f;
+           speed.z = 0.0f;
+           speed.y = 5.0f+Rand()*5.0f;
+           dim.x = Rand()*2.0f+2.0f;
+           dim.y = dim.x;
+           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f);
+       }
+
+       angle = m_object->RetCirVibration();
+       angle.y = m_progress*20.0f;
+       angle.x = sinf(m_progress*49.0f)*0.3f;
+       angle.z = sinf(m_progress*47.0f)*0.2f;
+       angle *= (1.0f-m_progress);
+       m_object->SetCirVibration(angle);
+   }
+
    if ( m_type == PT_FLCREATE )
    {
        if ( m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
@@ -1131,7 +1229,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = 2.0f+Rand()*2.0f;
            dim.x = (Rand()*1.0f+1.0f)*(0.2f+m_progress*0.8f);
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f, 0.0f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f);
        }
 
        angle = m_object->RetAngle(0);
@@ -1158,7 +1256,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = 2.0f+Rand()*2.0f;
            dim.x = (Rand()*1.0f+1.0f)*(0.2f+m_progress*0.8f);
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f, 0.5f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f);
        }
 
        angle = m_object->RetAngle(0);
@@ -1170,61 +1268,29 @@ BOOL CPyro::EventProcess(const Event &event)
        m_object->SetZoom(0, 1.0f-m_progress);
    }
 
-   if ( m_type == PT_RESET )
+   if ( m_type == PT_FINDING )
    {
-#if 0
-       if ( m_lastParticule+m_engine->ParticuleAdapt(0.10f) <= m_time )
-       {
-           m_lastParticule = m_time;
-
-           pos = m_pos;
-           speed.x = (Rand()-0.5f)*6.0f;
-           speed.z = (Rand()-0.5f)*6.0f;
-           speed.y = Rand()*12.0f;
-           dim.x = (Rand()*2.5f+2.5f)*(1.0f-m_progress*0.9f);
-           dim.y = dim.x;
-           pos.y += dim.y;
-           m_particule->CreateParticule(pos, speed, dim, 
-                                        (ParticuleType)(PARTILENS1+rand()%4),
-                                        Rand()*2.5f+2.5f,
-                                        Rand()*5.0f+5.0f, 0.0f);
-       }
-#else
-       if ( m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
+       if ( m_object != 0 &&
+            m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
        {
            m_lastParticule = m_time;
 
+           factor = m_size*0.3f;
+           if ( factor > 40.0f )  factor = 40.0f;
            pos = m_pos;
-           pos.x += (Rand()-0.5f)*5.0f;
-           pos.z += (Rand()-0.5f)*5.0f;
-           speed.x = 0.0f;
-           speed.z = 0.0f;
-           speed.y = 5.0f+Rand()*5.0f;
-           dim.x = Rand()*2.0f+2.0f;
-           dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIGLINTb, 2.0f);
-
-           pos = m_pos;
-           speed.x = (Rand()-0.5f)*20.0f;
-           speed.z = (Rand()-0.5f)*20.0f;
-           speed.y = Rand()*10.0f;
-           speed *= 0.5f+m_progress*0.5f;
-           dim.x = 0.6f;
+           m_terrain->MoveOnFloor(pos);
+           pos.x += (Rand()-0.5f)*factor;
+           pos.z += (Rand()-0.5f)*factor;
+           speed.x = (Rand()-0.5f)*2.0f;
+           speed.z = (Rand()-0.5f)*2.0f;
+           speed.y = 4.0f+Rand()*4.0f;
+           dim.x = (Rand()*3.0f+3.0f)*(1.0f-m_progress*0.9f);
            dim.y = dim.x;
-           pos.y += dim.y;
-           duration = Rand()*1.5f+1.5f;
-           m_particule->CreateTrack(pos, speed, dim, PARTITRACK6,
-                                    duration, 0.0f,
-                                    duration*0.9f, 0.7f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f);
        }
-#endif
-
-       angle = m_object->RetResetAngle();
-       m_object->SetAngleY(0, angle.y-powf((1.0f-m_progress)*5.0f, 2.0f));
-       m_object->SetZoom(0, m_progress);
    }
 
-   if ( m_type == PT_FINDING )
+   if ( m_type == PT_PAINTING )
    {
        if ( m_object != 0 &&
             m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
@@ -1232,22 +1298,22 @@ BOOL CPyro::EventProcess(const Event &event)
            m_lastParticule = m_time;
 
            factor = m_size*0.3f;
-           if ( m_object->RetType() == OBJECT_SAFE )  factor *= 1.3f;
            if ( factor > 40.0f )  factor = 40.0f;
            pos = m_pos;
            m_terrain->MoveOnFloor(pos);
            pos.x += (Rand()-0.5f)*factor;
            pos.z += (Rand()-0.5f)*factor;
-           speed.x = (Rand()-0.5f)*2.0f;
-           speed.z = (Rand()-0.5f)*2.0f;
-           speed.y = 4.0f+Rand()*4.0f;
-           dim.x = (Rand()*3.0f+3.0f)*(1.0f-m_progress*0.9f);
+           pos.y += 2.0f;
+           speed.x = (Rand()-0.5f)*1.0f;
+           speed.z = (Rand()-0.5f)*1.0f;
+           speed.y = 2.0f+Rand()*2.0f;
+           dim.x = (Rand()*0.2f+0.2f)*(1.0f-m_progress*0.9f);
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f, 0.5f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIGLINT, 2.0f, 0.0f);
        }
    }
 
-   if ( (m_type == PT_BURNT || m_type == PT_BURNO) &&
+   if ( (m_type == PT_BURNT || m_type == PT_BURNO || m_type == PT_BURNS) &&
         m_object != 0 )
    {
        if ( m_lastParticule+m_engine->ParticuleAdapt(0.05f) <= m_time )
@@ -1265,7 +1331,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = 0.0f;
            dim.x = (Rand()*2.5f+1.0f)*factor;
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIFLAME, 2.0f, 0.0f, 0.2f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIFLAME, 2.0f, 0.0f);
 
            pos = m_object->RetPosition(0);
            pos.y -= m_object->RetCharacter()->height;
@@ -1276,7 +1342,7 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = (Rand()*5.0f*m_progress+3.0f)*factor;
            dim.x = (Rand()*2.0f+1.0f)*factor;
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTIFLAME, 2.0f, 0.0f, 0.2f);
+           m_particule->CreateParticule(pos, speed, dim, PARTIFLAME, 2.0f, 0.0f);
 
            pos = m_object->RetPosition(0);
            pos.y -= 2.0f;
@@ -1286,26 +1352,55 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.z = 0.0f;
            speed.y = (6.0f+Rand()*6.0f+m_progress*6.0f)*factor;
            dim.x = (Rand()*1.5f+1.0f+m_progress*3.0f)*factor;
+           if ( m_type == PT_BURNO )  dim.x *= 2.0f;
            dim.y = dim.x;
            m_particule->CreateParticule(pos, speed, dim, PARTISMOKE3, 4.0f);
-       }
+
+           if ( m_type == PT_BURNO )
+           {
+               pos = m_object->RetPosition(0);
+               pos.y += 4.0f*(1.0f-m_progress);
+               speed.x = (Rand()-0.5f)*20.0f;
+               speed.z = (Rand()-0.5f)*20.0f;
+               speed.y = 5.0f+Rand()*10.0f;
+               dim.x = 0.8f*(1.0f-m_progress);
+               dim.y = dim.x;
+               m_particule->CreateParticule(pos, speed, dim, PARTIBLITZ, 1.0f, 40.0f);
+
+               if ( Rand() < 0.05f )  // assez rare ?
+               {
+                   speed.x = (Rand()-0.5f)*30.0f;
+                   speed.z = (Rand()-0.5f)*30.0f;
+                   speed.y = Rand()*30.0f+15.0f;
+                   dim.x = Rand()*1.0f+1.0f;
+                   dim.y = dim.x;
+                   m_particule->CreateTrack(pos, speed, dim, PARTITRACK4, 2.0f, 50.0f, 1.2f, 1.8f);
+               }
+           }
+       }
 
        if ( m_type == PT_BURNT )
        {
            BurnProgress();
        }
-       else
+       if ( m_type == PT_BURNO )
        {
            speed.y = 0.0f;
-           speed.x = (Rand()-0.5f)*m_progress*1.0f;
-           speed.z = (Rand()-0.5f)*m_progress*1.0f;
-           if ( m_progress > 0.8f )
+           speed.x = (Rand()-0.5f)*m_progress*0.5f;
+           speed.z = (Rand()-0.5f)*m_progress*0.5f;
+           m_object->SetLinVibration(speed);
+           speed.y = (Rand()-0.5f)*m_progress*2.0f;
+           speed.x = (Rand()-0.5f)*m_progress*0.5f;
+           speed.z = (Rand()-0.5f)*m_progress*0.5f;
+           m_object->SetCirVibration(speed);
+           factor = 1.0f-powf(m_progress, 2.0f);
+           if ( factor < 0.1f )  factor = 0.1f;
+           m_object->SetZoom(0, factor);
+
+           if ( m_object->RetType() == OBJECT_EVIL3 )  // roi ?
            {
-               prog = (m_progress-0.8f)/0.2f;  // 0..1
-               speed.y = -prog*6.0f;  // s'enfonce dans le sol
-               m_object->SetZoom(0, 1.0f-prog*0.5f);
+               m_object->SetZoom(1, 1.0f/factor);
            }
-           m_object->SetLinVibration(speed);
        }
    }
 
@@ -1343,15 +1438,10 @@ BOOL CPyro::EventProcess(const Event &event)
            speed.y = 1.0f+Rand()*1.0f;
            dim.x = Rand()*1.0f+1.0f;
            dim.y = dim.x;
-           m_particule->CreateParticule(pos, speed, dim, PARTISMOKE1, 8.0f, 0.0f, 0.0f);
+           m_particule->CreateParticule(pos, speed, dim, PARTISMOKE1, 8.0f, 0.0f);
        }
    }
 
-   if ( m_type == PT_FALL )
-   {
-       FallProgress(event.rTime);
-   }
-
    if ( m_lightRank != -1 )
    {
        LightOperFrame(event.rTime);
@@ -1378,6 +1468,7 @@ Error CPyro::IsEnded()
    // du Create, car c'est parfois l'objet lui-même qui fait le Create :
    //  pyro->Create(PT_FRAGT, this);
    if ( m_type == PT_FRAGT  ||
+        m_type == PT_FRAGA  ||
         m_type == PT_FRAGO  ||
         m_type == PT_FRAGW  ||
         m_type == PT_SPIDER ||
@@ -1386,11 +1477,6 @@ Error CPyro::IsEnded()
        DeleteObject(TRUE, TRUE);
    }
 
-   if ( m_type == PT_FALL )  // fret qui tombe ?
-   {
-       return FallIsEnded();
-   }
-
    if ( m_type == PT_WIN  ||
         m_type == PT_LOST )
    {
@@ -1401,12 +1487,24 @@ Error CPyro::IsEnded()
    if ( m_progress < 1.0f )  return ERR_CONTINUE;
 
    if ( m_type == PT_EXPLOT ||
-        m_type == PT_EXPLOO ||
-        m_type == PT_EXPLOW )  // explosion ?
+        m_type == PT_EXPLOW ||
+        m_type == PT_EJECT  )  // explosion ?
    {
        ExploTerminate();
    }
 
+   if ( m_type == PT_EXPLOO )  // explosion ?
+   {
+       OrgaTerminate();
+   }
+
+   if ( m_type == PT_ACROBATIC ||
+        m_type == PT_SABOTAGE  ||
+        m_type == PT_PIECE     )
+   {
+       AcrobaticTerminate();
+   }
+
    if ( m_type == PT_BURNT ||
         m_type == PT_BURNO )  // brûle ?
    {
@@ -1426,13 +1524,6 @@ Error CPyro::IsEnded()
        m_object->SetZoom(0, 1.0f);
    }
 
-   if ( m_type == PT_RESET )
-   {
-       m_object->SetPosition(0, m_object->RetResetPosition());
-       m_object->SetAngle(0, m_object->RetResetAngle());
-       m_object->SetZoom(0, 1.0f);
-   }
-
    if ( m_lightRank != -1 )
    {
        m_light->DeleteLight(m_lightRank);
@@ -1452,20 +1543,8 @@ void CPyro::DeleteObject(BOOL bPrimary, BOOL bSecondary)
 
    if ( m_object == 0 )  return;
 
-   if ( m_object->RetResetCap() == RESET_MOVE )  // objet resetable ?
-   {
-       m_object->SetEnable(FALSE);  // objet caché et inactif
-       pos = m_object->RetPosition(0);
-       pos.y = -100.0f;
-       m_object->SetPosition(0, pos);
-       return;
-   }
-
    type = m_object->RetType();
-   if ( bSecondary             &&
-        type != OBJECT_FACTORY &&
-        type != OBJECT_NUCLEAR &&
-        type != OBJECT_ENERGY  )
+   if ( bSecondary )
    {
        sub = m_object->RetPower();
        if ( sub != 0 )
@@ -1603,9 +1682,10 @@ BOOL CPyro::CreateLight(D3DVECTOR pos, float height)
 
 // Démarre l'explosion d'un véhicule.
 
-void CPyro::ExploStart()
+void CPyro::ExploStart(ObjectType oType)
 {
    D3DVECTOR   pos, angle, speed, min, max;
+   FPOINT      dim;
    float       weight;
    int         i, objRank, channel;
 
@@ -1625,41 +1705,52 @@ void CPyro::ExploStart()
        m_camera->SetType(CAMERA_EXPLO);
        m_main->DeselectAll();
    }
-   m_object->DeleteDeselList(m_object);
 
    for ( i=0 ; i<OBJECTMAXPART ; i++ )
    {
        objRank = m_object->RetObjectRank(i);
        if ( objRank == -1 )  continue;
-       m_engine->ChangeSecondTexture(objRank, "dirty04.tga");
+
+       if ( m_type != PT_EJECT )
+       {
+           m_engine->ChangeSecondTexture(objRank, "dirty04.tga");
+       }
 
        pos = m_object->RetPosition(i);
 
-       if ( i == 0 )  // partie principale ?
-       {
-           weight = 0.0f;
+       m_engine->GetBBox(objRank, min, max);
+       weight = Length(min, max);  // poids selon dimensions !
 
-           speed.y = -1.0f;
-           speed.x = 0.0f;
-           speed.z = 0.0f;
-       }
-       else
+       speed.y = 10.0f+Rand()*20.0f;
+       speed.x = (Rand()-0.5f)*20.0f;
+       speed.z = (Rand()-0.5f)*20.0f;
+
+       dim.x = weight/2.0f;
+       dim.y = dim.x;
+
+       if ( m_type == PT_EJECT )
        {
-           m_engine->GetBBox(objRank, min, max);
-           weight = Length(min, max);  // poids selon dimensions !
+           pos.y += 3.0f;
+           speed.y *= 0.8f;
 
-           speed.y = 10.0f+Rand()*20.0f;
-           speed.x = (Rand()-0.5f)*20.0f;
-           speed.z = (Rand()-0.5f)*20.0f;
+           if ( oType >= OBJECT_CARCASS1 && oType <= OBJECT_CARCASS10 )
+           {
+               pos.y += 3.0f;
+               speed.y *= 1.5f;
+           }
        }
 
-       channel = m_particule->CreatePart(pos, speed, PARTIPART, 10.0f, 20.0f, weight, 0.5f);
+       channel = m_particule->CreatePart(pos, speed, dim, PARTIPART, 10.0f, 20.0f, weight);
        if ( channel != -1 )
        {
            m_object->SetMasterParticule(i, channel);
        }
    }
-   m_engine->LoadTexture("dirty04.tga", 1);
+
+   if ( m_type != PT_EJECT )
+   {
+       m_engine->LoadTexture("dirty04.tga", 1);
+   }
 
    DeleteObject(FALSE, TRUE);  // détruit l'objet transporté + la pile
 }
@@ -1672,6 +1763,352 @@ void CPyro::ExploTerminate()
 }
 
 
+// Démarre l'explosion d'un objet organique vert.
+
+void CPyro::OrgaStart()
+{
+   m_object->SetLock(TRUE);  // plus utilisable
+   m_object->SetExplo(TRUE);  // en cours de destruction
+
+   if ( m_object->RetType() == m_main->RetTypeProgress() )
+   {
+       m_main->IncProgress();
+   }
+
+}
+
+// Fait progresser l'explosion d'un objet organique vert.
+
+void CPyro::OrgaProgress()
+{
+#if 1
+   D3DVECTOR   zoom;
+   float       progress;
+
+   if ( m_progress < 0.1f )
+   {
+       progress = m_progress/0.1f;
+       zoom.y = 1.0f-progress;
+       if ( zoom.y < 0.01f )  zoom.y = 0.01f;
+       zoom.x = 1.0f+progress*1.0f;
+       zoom.z = zoom.x;
+   }
+   else if ( m_progress < 0.7f )
+   {
+       progress = (m_progress-0.1f)/0.6f;
+       zoom.y = 0.01f;
+       zoom.x = 2.0f;
+       zoom.z = zoom.x;
+   }
+   else
+   {
+       progress = (m_progress-0.7f)/0.3f;
+       zoom.y = 0.01f;
+       zoom.x = 2.0f-progress*2.0f;
+       zoom.z = zoom.x;
+   }
+   m_object->SetZoom(0, zoom);
+#else
+   float   zoom;
+   float   progress;
+
+   if ( m_progress < 0.1f )
+   {
+       progress = m_progress/0.1f;
+       zoom = 1.0f-progress;
+   }
+   else
+   {
+       zoom = 0.0f;
+   }
+   m_object->SetZoom(0, zoom);
+#endif
+}
+
+// Termine l'explosion d'un objet organique vert.
+
+void CPyro::OrgaTerminate()
+{
+   DeleteObject(TRUE, TRUE);
+}
+
+
+// Démarre la voltige d'un robot ou d'un objet heurté.
+
+void CPyro::AcrobaticStart(D3DVECTOR min, D3DVECTOR max)
+{
+   ObjectType  type;
+   D3DMATRIX*  mat;
+   D3DVECTOR   cdg, pos, n, angle, speed, size;
+   FPOINT      nn, dim;
+   float       a, duration, little, radius, d;
+
+   m_angleStart.x = NormAngle(m_angleStart.x);
+   m_angleStart.y = NormAngle(m_angleStart.y);
+   m_angleStart.z = NormAngle(m_angleStart.z);
+
+   m_angleGoal = m_angleStart;
+
+   m_height = m_force*10.0f;
+   if ( m_height > 16.0f )  m_height = 16.0f;
+
+   if ( m_height < 6.0f )
+   {
+       m_speed = 1.0f/1.0f;
+       m_height = 0.0f;
+   }
+   else
+   {
+       m_speed = 1.0f/(1.0f+(m_height/16.0f));
+   }
+
+   m_heightSuppl = 0.0f;
+
+   m_object->SetLock(TRUE);  // plus utilisable
+   m_object->SetExplo(TRUE);  // en cours de destruction
+
+   cdg = (min+max)/2.0f;  // centre de gravité
+   size = max-min;  // dimensions
+
+   d = 1.2f-Norm(Length(size)*0.2f)*0.4f;
+   m_height *= d;
+   m_speed *= 1.0f/d;
+
+   type = m_object->RetType();
+   if ( m_type == PT_PIECE )  // pièce de voiture ?
+   {
+       m_heightSuppl = -m_terrain->RetFloorHeight(m_posStart);
+
+       little = Min(size.x, size.y, size.z);
+       if ( m_param == 1 )  // force rotation en x ?
+       {
+           little = size.z;
+       }
+       if ( size.x == little )  // pièce mince en x ?
+       {
+           angle = D3DVECTOR(0.0f, 0.0f, -PI/2.0f);
+       }
+       else if ( size.z == little )  // pièce mince en z ?
+       {
+           angle = D3DVECTOR(-PI/2.0f, 0.0f, 0.0f);
+       }
+       else    // pièce mince en y ?
+       {
+           angle = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       }
+       AcrobaticTransform(type, cdg, angle, min, max);
+
+       m_angleGoal.y += (Rand()-0.5f)*PI*2.0f;  // autre orientation
+
+       if ( m_terrain->GetNormal(n, m_posStart) )
+       {
+           a = m_angleGoal.y;
+           nn = RotatePoint(-a, FPOINT(n.z, n.x));
+           m_angleGoal.x =  sinf(nn.x);
+           m_angleGoal.z = -sinf(nn.y);  // plaque au sol
+       }
+   }
+   else
+   {
+       if ( type != OBJECT_BOT1    &&
+            type != OBJECT_BOT2    &&
+            type != OBJECT_BOT3    &&
+            type != OBJECT_BOT4    &&
+            type != OBJECT_BOT5    &&
+            type != OBJECT_CARROT  &&
+            type != OBJECT_STARTER &&
+            type != OBJECT_WALKER  &&
+            type != OBJECT_CRAZY   &&
+            type != OBJECT_GUIDE   )
+       {
+           if ( !m_object->RetGround() )  // pas encore à terre ?
+           {
+               angle = D3DVECTOR(-PI/2.0f, 0.0f, 0.0f);
+               AcrobaticTransform(type, cdg, angle, min, max);
+           }
+           m_angleGoal.y += (Rand()-0.5f)*PI*2.0f;  // autre orientation
+
+           pos = m_object->RetPosition(0);
+           if ( m_terrain->GetNormal(n, pos) )
+           {
+               a = m_angleGoal.y;
+               nn = RotatePoint(-a, FPOINT(n.z, n.x));
+               m_angleGoal.x =  sinf(nn.x);
+               m_angleGoal.z = -sinf(nn.y);  // plaque au sol
+               m_angleGoal.x = m_angleStart.x+Direction(m_angleStart.x, m_angleGoal.x);
+               m_angleGoal.z = m_angleStart.z+Direction(m_angleStart.z, m_angleGoal.z);
+           }
+       }
+   }
+
+   if ( m_height == 0.0f )
+   {
+       m_angleGoal.y += PI*2.0f;  // pirouette
+   }
+   else if ( m_height < 11.0f )
+   {
+       m_angleGoal.y += PI*2.0f;
+       m_angleGoal.z += PI*2.0f;  // pirouette
+   }
+   else
+   {
+       m_angleGoal.x += PI*2.0f;
+       m_angleGoal.y += PI*2.0f;
+       m_angleGoal.z += PI*2.0f;  // pirouette
+   }
+
+   radius = Length(size)/2.0f;
+   dim.x = Length(max-min)*0.7f*(m_height/5.0f);
+   if ( radius > 3.0f && dim.x > 4.0f )
+   {
+       if ( dim.x > 12.0f )  dim.x = 12.0f;
+       dim.y = dim.x;
+       mat = m_object->RetWorldMatrix(0);
+       pos = Transform(*mat, cdg);
+       speed = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       duration = 0.3f;
+       m_particule->CreateParticule(pos, speed, dim, PARTIBIGT, duration);
+   }
+}
+
+// Transforme un objet pour qu'il devienne indépendant.
+
+void CPyro::AcrobaticTransform(ObjectType type, D3DVECTOR cdg, D3DVECTOR angle,
+                              D3DVECTOR min, D3DVECTOR max)
+{
+   D3DVECTOR   move1, move2;
+   int         i, objRank;
+
+   if ( angle.z != 0.0f )
+   {
+       move1 = -cdg;
+       move2 = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       AcrobaticGroundAdapt(type, angle, move2);
+
+       for ( i=0 ; i<OBJECTMAXPART ; i++ )
+       {
+           objRank = m_object->RetObjectRank(i);
+           if ( objRank == -1 )  continue;
+           m_engine->TransformObject(objRank, move1, angle, move2);
+       }
+
+       m_posStart.y += -min.x;
+   }
+   else if ( angle.x != 0.0f )
+   {
+       move1 = -cdg;
+       move2 = D3DVECTOR(0.0f, 0.0f, 0.0f);
+       AcrobaticGroundAdapt(type, angle, move2);
+
+       for ( i=0 ; i<OBJECTMAXPART ; i++ )
+       {
+           objRank = m_object->RetObjectRank(i);
+           if ( objRank == -1 )  continue;
+           m_engine->TransformObject(objRank, move1, angle, move2);
+       }
+
+       m_posStart.y += -min.z;
+   }
+   else
+   {
+       m_posStart.y += -min.y;
+   }
+}
+
+// Adapte l'angle d'un objet pour qu'il repose au sol sur le flan.
+
+void CPyro::AcrobaticGroundAdapt(ObjectType type, D3DVECTOR &angle, D3DVECTOR &pos)
+{
+   if ( type == OBJECT_CONE )
+   {
+       angle.x -= 17.0f*PI/180.0f;
+       m_posStart.y -= 0.4f;
+   }
+   if ( type == OBJECT_BARRIER4 )
+   {
+       angle.z -= 6.0f*PI/180.0f;
+       angle.x -= 3.0f*PI/180.0f;
+       m_posStart.y -= 0.5f;
+   }
+   if ( type == OBJECT_BARRIER5 )
+   {
+       angle.x -= 3.0f*PI/180.0f;
+       m_posStart.y -= 0.1f;
+   }
+   if ( type == OBJECT_CARCASS1 )
+   {
+       angle.x -= 20.0f*PI/180.0f;  // sur le côté
+   }
+   if ( type == OBJECT_CARCASS2 )
+   {
+       angle.x += 160.0f*PI/180.0f;  // sur le toît
+       m_posStart.y += 1.0f;
+   }
+}
+
+// Fait progresser la voltige d'un robor heurté.
+
+void CPyro::AcrobaticProgress()
+{
+   D3DVECTOR   pos, angle;
+   float       progress;
+
+   progress = Norm(m_progress);
+
+   pos = m_posStart;
+   pos.y += sinf(progress*PI)*m_height;
+
+   if ( progress > 0.5f )
+   {
+       pos.y += m_heightSuppl*((progress-0.5f)/0.5f);
+   }
+
+   if ( m_type == PT_SABOTAGE )
+   {
+       pos.x += (m_impact.x-pos.x)*progress;
+       pos.z += (m_impact.z-pos.z)*progress;
+   }
+   m_object->SetPosition(0, pos);
+
+//?    angle = m_angleStart+(m_angleGoal-m_angleStart)*progress;
+   angle = m_angleStart+(m_angleGoal-m_angleStart)*powf(progress, 0.5f);
+//?    angle.x += PI*2.0f*powf(progress, 0.5f);  // pirouette
+//?    angle.y += PI*2.0f*powf(progress, 0.5f);  // pirouette
+//?    angle.z += PI*2.0f*powf(progress, 0.5f);  // pirouette
+   m_object->SetAngle(0, angle);
+}
+
+// Termine la voltige d'un robor heurté.
+
+void CPyro::AcrobaticTerminate()
+{
+   ObjectType  type;
+   Sound       sound;
+
+   m_progress = 1.0f;
+   AcrobaticProgress();
+
+   if ( m_height > 0.0f )
+   {
+       type = m_object->RetType();
+
+       if ( type == OBJECT_CONE )
+       {
+           sound = SOUND_BOUMv;
+       }
+       else
+       {
+           sound = (Sound)(SOUND_FALLo1+rand()%2);
+       }
+       m_sound->Play(sound, m_posStart);
+   }
+
+   m_object->SetLock(FALSE);  // de nouveau utilisable
+   m_object->SetExplo(FALSE);  // destruction terminée
+   m_object->SetGround(TRUE);  // à terre
+}
+
+
 // Démarre le feu d'un véhicule.
 
 void CPyro::BurnStart()
@@ -1686,6 +2123,7 @@ void CPyro::BurnStart()
 
    m_object->Simplify();
    m_object->SetLock(TRUE);  // ruine pas encore utilisable
+   m_object->SetExplo(TRUE);  // en cours de destruction
 
    if ( m_object->RetSelect() )
    {
@@ -1693,7 +2131,6 @@ void CPyro::BurnStart()
        m_camera->SetType(CAMERA_EXPLO);
        m_main->DeselectAll();
    }
-   m_object->DeleteDeselList(m_object);
 
    for ( i=0 ; i<OBJECTMAXPART ; i++ )
    {
@@ -1705,15 +2142,7 @@ void CPyro::BurnStart()
 
    m_burnPartTotal = 0;
 
-   if ( m_burnType == OBJECT_DERRICK  ||
-        m_burnType == OBJECT_FACTORY  ||
-        m_burnType == OBJECT_REPAIR   ||
-        m_burnType == OBJECT_DESTROYER||
-        m_burnType == OBJECT_CONVERT  ||
-        m_burnType == OBJECT_TOWER    ||
-        m_burnType == OBJECT_RESEARCH ||
-        m_burnType == OBJECT_ENERGY   ||
-        m_burnType == OBJECT_LABO     )
+   if ( m_burnType == OBJECT_TOWER )
    {
        pos.x =   0.0f;
        pos.y = -(4.0f+Rand()*4.0f);
@@ -1722,17 +2151,6 @@ void CPyro::BurnStart()
        angle.y = 0.0f;
        angle.z = (Rand()-0.5f)*0.4f;
    }
-   else if ( m_burnType == OBJECT_STATION ||
-             m_burnType == OBJECT_RADAR   ||
-             m_burnType == OBJECT_INFO    )
-   {
-       pos.x =   0.0f;
-       pos.y = -(1.0f+Rand()*1.0f);
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = 0.0f;
-       angle.z = (Rand()-0.5f)*0.2f;
-   }
    else if ( m_burnType == OBJECT_NUCLEAR )
    {
        pos.x =   0.0f;
@@ -1751,43 +2169,30 @@ void CPyro::BurnStart()
        angle.y = 0.0f;
        angle.z = (Rand()-0.5f)*0.4f;
    }
-   else if ( m_burnType == OBJECT_SAFE )
+   else if ( m_burnType == OBJECT_CAR )
    {
        pos.x =   0.0f;
-       pos.y = -(10.0f+Rand()*10.0f);
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.4f;
-       angle.y = 0.0f;
-       angle.z = (Rand()-0.5f)*0.4f;
-   }
-   else if ( m_burnType == OBJECT_HUSTON )
-   {
-       pos.x =   0.0f;
-       pos.y = -(10.0f+Rand()*10.0f);
+       pos.y = -(0.5f+Rand()*1.0f);
        pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.4f;
+       angle.x = (Rand()-0.5f)*0.8f;
        angle.y = 0.0f;
        angle.z = (Rand()-0.5f)*0.4f;
    }
-   else if ( m_burnType == OBJECT_MOBILEwa ||
-             m_burnType == OBJECT_MOBILEwc ||
-             m_burnType == OBJECT_MOBILEwi ||
-             m_burnType == OBJECT_MOBILEws ||
-             m_burnType == OBJECT_MOBILEwt )
+   else if ( m_burnType == OBJECT_EVIL1 )
    {
        pos.x =   0.0f;
-       pos.y = -(0.5f+Rand()*1.0f);
+       pos.y =  -7.0f;
        pos.z =   0.0f;
        angle.x = (Rand()-0.5f)*0.8f;
        angle.y = 0.0f;
        angle.z = (Rand()-0.5f)*0.4f;
    }
-   else if ( m_burnType == OBJECT_TEEN31 )  // basket ?
+   else if ( m_burnType == OBJECT_EVIL3 )
    {
        pos.x =   0.0f;
-       pos.y =   0.0f;
+       pos.y = -20.0f;
        pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.8f;
+       angle.x = (Rand()-0.5f)*0.4f;
        angle.y = 0.0f;
        angle.z = (Rand()-0.5f)*0.2f;
    }
@@ -1804,52 +2209,6 @@ void CPyro::BurnStart()
 
    m_burnKeepPart[0] = -1;  // rien à garder
 
-   if ( m_burnType == OBJECT_DERRICK )
-   {
-       pos.x =   0.0f;
-       pos.y = -40.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le foret
-   }
-
-   if ( m_burnType == OBJECT_REPAIR )
-   {
-       pos.x =   0.0f;
-       pos.y = -12.0f;
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = (Rand()-0.5f)*0.2f;
-       angle.z = -90.0f*PI/180.0f;
-       BurnAddPart(1, pos, angle);  // descend le capteur
-   }
-
-   if ( m_burnType == OBJECT_DESTROYER )
-   {
-       pos.x =   0.0f;
-       pos.y = -12.0f;
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = (Rand()-0.5f)*0.2f;
-       angle.z = -90.0f*PI/180.0f;
-       BurnAddPart(1, pos, angle);  // descend le capteur
-   }
-
-   if ( m_burnType == OBJECT_CONVERT )
-   {
-       pos.x =    0.0f;
-       pos.y = -200.0f;
-       pos.z =    0.0f;
-       angle.x = (Rand()-0.5f)*0.5f;
-       angle.y = (Rand()-0.5f)*0.5f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le couvercle
-       BurnAddPart(2, pos, angle);
-       BurnAddPart(3, pos, angle);
-   }
-
    if ( m_burnType == OBJECT_TOWER )
    {
        pos.x =  0.0f;
@@ -1861,52 +2220,6 @@ void CPyro::BurnStart()
        BurnAddPart(1, pos, angle);  // descend le canon
    }
 
-   if ( m_burnType == OBJECT_RESEARCH )
-   {
-       pos.x =  0.0f;
-       pos.y = -7.0f;
-       pos.z =  0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = (Rand()-0.5f)*0.2f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend l'anémomètre
-   }
-
-   if ( m_burnType == OBJECT_RADAR )
-   {
-       pos.x =   0.0f;
-       pos.y = -14.0f;
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.4f;
-       angle.y = (Rand()-0.5f)*0.4f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le radar
-       BurnAddPart(2, pos, angle);
-   }
-
-   if ( m_burnType == OBJECT_INFO )
-   {
-       pos.x =   0.0f;
-       pos.y = -14.0f;
-       pos.z =   0.0f;
-       angle.x = (Rand()-0.5f)*0.4f;
-       angle.y = (Rand()-0.5f)*0.4f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend la borne d'information
-       BurnAddPart(2, pos, angle);
-   }
-
-   if ( m_burnType == OBJECT_LABO )
-   {
-       pos.x =   0.0f;
-       pos.y = -12.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le bras
-   }
-
    if ( m_burnType == OBJECT_NUCLEAR )
    {
        pos.x = 0.0f;
@@ -1918,38 +2231,7 @@ void CPyro::BurnStart()
        BurnAddPart(1, pos, angle);  // descend le couvercle
    }
 
-   if ( m_burnType == OBJECT_MOBILEfa ||
-        m_burnType == OBJECT_MOBILEta ||
-        m_burnType == OBJECT_MOBILEwa ||
-        m_burnType == OBJECT_MOBILEia )
-   {
-       pos.x =  2.0f;
-       pos.y = -5.0f;
-       pos.z =  0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = (Rand()-0.5f)*0.2f;
-       angle.z = 40.0f*PI/180.0f;
-       BurnAddPart(1, pos, angle);  // descend le bras
-   }
-
-   if ( m_burnType == OBJECT_MOBILEfs ||
-        m_burnType == OBJECT_MOBILEts ||
-        m_burnType == OBJECT_MOBILEws ||
-        m_burnType == OBJECT_MOBILEis )
-   {
-       pos.x =  0.0f;
-       pos.y = -7.0f;
-       pos.z =  0.0f;
-       angle.x = (Rand()-0.5f)*0.2f;
-       angle.y = (Rand()-0.5f)*0.2f;
-       angle.z = 50.0f*PI/180.0f;
-       BurnAddPart(1, pos, angle);  // descend le capteur
-   }
-
-   if ( m_burnType == OBJECT_MOBILEfc ||
-        m_burnType == OBJECT_MOBILEtc ||
-        m_burnType == OBJECT_MOBILEwc ||
-        m_burnType == OBJECT_MOBILEic )
+   if ( m_burnType == OBJECT_MOBILEfb )
    {
        pos.x = -1.5f;
        pos.y = -5.0f;
@@ -1960,10 +2242,7 @@ void CPyro::BurnStart()
        BurnAddPart(1, pos, angle);  // descend le canon
    }
 
-   if ( m_burnType == OBJECT_MOBILEfi ||
-        m_burnType == OBJECT_MOBILEti ||
-        m_burnType == OBJECT_MOBILEwi ||
-        m_burnType == OBJECT_MOBILEii )
+   if ( m_burnType == OBJECT_MOBILEob )
    {
        pos.x = -1.5f;
        pos.y = -5.0f;
@@ -1974,96 +2253,8 @@ void CPyro::BurnStart()
        BurnAddPart(1, pos, angle);  // descend le canon-insecte
    }
 
-   if ( m_burnType == OBJECT_MOBILErt ||
-        m_burnType == OBJECT_MOBILErc )
-   {
-       pos.x =   0.0f;
-       pos.y = -10.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le support
-
-       pos.x =   0.0f;
-       pos.y = -10.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(2, pos, angle);  // descend le pilon/canon
-   }
-
-   if ( m_burnType == OBJECT_MOBILErr )
-   {
-       pos.x =   0.0f;
-       pos.y = -10.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le support
-
-       pos.x =   0.0f;
-       pos.y =   0.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = -PI/2.0f;
-       BurnAddPart(4, pos, angle);
-
-       pos.x =   0.0f;
-       pos.y =   0.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = PI/2.5f;
-       BurnAddPart(2, pos, angle);
-   }
-
-   if ( m_burnType == OBJECT_MOBILErs )
-   {
-       pos.x =   0.0f;
-       pos.y = -10.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le support
-
-       pos.x =   0.0f;
-       pos.y =  -5.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(2, pos, angle);
-
-       pos.x =   0.0f;
-       pos.y =  -5.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(3, pos, angle);
-   }
-
-   if ( m_burnType == OBJECT_MOBILEsa )
-   {
-       pos.x =   0.0f;
-       pos.y = -10.0f;
-       pos.z =   0.0f;
-       angle.x = 0.0f;
-       angle.y = 0.0f;
-       angle.z = 0.0f;
-       BurnAddPart(1, pos, angle);  // descend le support
-   }
-
-   if ( m_burnType == OBJECT_MOBILEwa ||
-        m_burnType == OBJECT_MOBILEwc ||
-        m_burnType == OBJECT_MOBILEwi ||
-        m_burnType == OBJECT_MOBILEws ||
-        m_burnType == OBJECT_MOBILEwt )  // roues ?
+   if ( m_burnType == OBJECT_CAR      ||
+        m_burnType == OBJECT_MOBILEtg )  // roues ?
    {
        for ( i=0 ; i<4 ; i++ )
        {
@@ -2080,16 +2271,8 @@ void CPyro::BurnStart()
        m_burnKeepPart[i] = -1;
    }
 
-   if ( m_burnType == OBJECT_MOBILEta ||
-        m_burnType == OBJECT_MOBILEtc ||
-        m_burnType == OBJECT_MOBILEti ||
-        m_burnType == OBJECT_MOBILEts ||
-        m_burnType == OBJECT_MOBILErt ||
-        m_burnType == OBJECT_MOBILErc ||
-        m_burnType == OBJECT_MOBILErr ||
-        m_burnType == OBJECT_MOBILErs ||
-        m_burnType == OBJECT_MOBILEsa ||
-        m_burnType == OBJECT_MOBILEdr )  // chenilles ?
+   if ( m_burnType == OBJECT_MOBILEfb ||
+        m_burnType == OBJECT_MOBILEob )  // chenilles ?
    {
        pos.x =   0.0f;
        pos.y =  -4.0f;
@@ -2107,42 +2290,6 @@ void CPyro::BurnStart()
        angle.z = (Rand()-0.5f)*30.0f*PI/180.0f;
        BurnAddPart(7, pos, angle);  // descend la chenille gauche
    }
-
-   if ( m_burnType == OBJECT_MOBILEfa ||
-        m_burnType == OBJECT_MOBILEfc ||
-        m_burnType == OBJECT_MOBILEfi ||
-        m_burnType == OBJECT_MOBILEfs ||
-        m_burnType == OBJECT_MOBILEft )  // volant ?
-   {
-       for ( i=0 ; i<3 ; i++ )
-       {
-           pos.x =  0.0f;
-           pos.y = -3.0f;
-           pos.z =  0.0f;
-           angle.x = 0.0f;
-           angle.y = 0.0f;
-           angle.z = (Rand()-0.5f)*PI/2.0f;
-           BurnAddPart(6+i, pos, angle);  // pied
-       }
-       m_burnKeepPart[i] = -1;
-   }
-
-   if ( m_burnType == OBJECT_MOBILEia ||
-        m_burnType == OBJECT_MOBILEic ||
-        m_burnType == OBJECT_MOBILEii ||
-        m_burnType == OBJECT_MOBILEis )  // pattes ?
-   {
-       for ( i=0 ; i<6; i++ )
-       {
-           pos.x =  0.0f;
-           pos.y = -3.0f;
-           pos.z =  0.0f;
-           angle.x = 0.0f;
-           angle.y = (Rand()-0.5f)*PI/4.0f;
-           angle.z = (Rand()-0.5f)*PI/4.0f;
-           BurnAddPart(6+i, pos, angle);  // patte
-       }
-   }
 }
 
 // Ajoute une partie à bouger.
@@ -2165,15 +2312,11 @@ void CPyro::BurnAddPart(int part, D3DVECTOR pos, D3DVECTOR angle)
 
 void CPyro::BurnProgress()
 {
-   CObject*    sub;
    D3DVECTOR   pos;
    float       h;
    int         i;
 
-   if ( m_burnType == OBJECT_TEEN31 )  // basket ?
-   {
-       m_object->SetZoomY(0, 1.0f-m_progress*0.5f);  // léger applatissement
-   }
+//?    m_object->SetZoomY(0, 1.0f-m_progress*0.2f);  // léger applatissement
 
    for ( i=0 ; i<m_burnPartTotal ; i++ )
    {
@@ -2190,10 +2333,10 @@ void CPyro::BurnProgress()
        m_object->SetAngle(m_burnPart[i].part, pos);
    }
 
-   sub = m_object->RetPower();
-   if ( sub != 0 )  // y a-t-il une pile ?
+   if ( m_burnType == OBJECT_EVIL1 ||
+        m_burnType == OBJECT_EVIL3 )
    {
-       sub->SetZoomY(0, 1.0f-m_progress);  // aplatissement complet
+       m_object->SetZoomY(0, 1.0f-m_progress);  // aplatissement complet
    }
 }
 
@@ -2234,22 +2377,12 @@ void CPyro::BurnTerminate()
 
    DeleteObject(FALSE, TRUE);  // détruit l'objet transporté + la pile
 
-   if ( m_burnType == OBJECT_DERRICK  ||
-        m_burnType == OBJECT_STATION  ||
-        m_burnType == OBJECT_FACTORY  ||
-        m_burnType == OBJECT_REPAIR   ||
-        m_burnType == OBJECT_DESTROYER||
-        m_burnType == OBJECT_CONVERT  ||
-        m_burnType == OBJECT_TOWER    ||
-        m_burnType == OBJECT_RESEARCH ||
-        m_burnType == OBJECT_RADAR    ||
-        m_burnType == OBJECT_INFO     ||
-        m_burnType == OBJECT_ENERGY   ||
-        m_burnType == OBJECT_LABO     ||
+   if ( m_burnType == OBJECT_TOWER    ||
         m_burnType == OBJECT_NUCLEAR  ||
         m_burnType == OBJECT_PARA     ||
-        m_burnType == OBJECT_SAFE     ||
-        m_burnType == OBJECT_HUSTON   ||
+        m_burnType == OBJECT_DOCK     ||
+        m_burnType == OBJECT_REMOTE   ||
+        m_burnType == OBJECT_STAND    ||
         m_burnType == OBJECT_START    ||
         m_burnType == OBJECT_END      )
    {
@@ -2266,205 +2399,3 @@ void CPyro::BurnTerminate()
 }
 
 
-// Début d'un objet fret qui tombe.
-
-void CPyro::FallStart()
-{
-   D3DVECTOR   pos;
-
-   m_object->SetBurn(TRUE);  // plus utilisable
-
-   pos = m_object->RetPosition(0);
-   m_fallFloor = m_terrain->RetFloorLevel(pos);
-   m_fallSpeed = 0.0f;
-   m_fallBulletTime = 0.0f;
-   m_bFallEnding = FALSE;
-}
-
-// Cherche un objet à exploser par le boulet de l'abeille qui tombe.
-
-CObject* CPyro::FallSearchBeeExplo()
-{
-   CObject*    pObj;
-   D3DVECTOR   iPos, oPos;
-   ObjectType  oType;
-   float       iRadius, oRadius, distance, shieldRadius;
-   int         i, j;
-
-   m_object->GetCrashSphere(0, iPos, iRadius);
-
-   for ( i=0 ; i<1000000 ; i++ )
-   {
-       pObj = (CObject*)m_iMan->SearchInstance(CLASS_OBJECT, i);
-       if ( pObj == 0 )  break;
-
-       oType = pObj->RetType();
-       if ( oType != OBJECT_HUMAN    &&
-            oType != OBJECT_MOBILEfa &&
-            oType != OBJECT_MOBILEta &&
-            oType != OBJECT_MOBILEwa &&
-            oType != OBJECT_MOBILEia &&
-            oType != OBJECT_MOBILEfc &&
-            oType != OBJECT_MOBILEtc &&
-            oType != OBJECT_MOBILEwc &&
-            oType != OBJECT_MOBILEic &&
-            oType != OBJECT_MOBILEfi &&
-            oType != OBJECT_MOBILEti &&
-            oType != OBJECT_MOBILEwi &&
-            oType != OBJECT_MOBILEii &&
-            oType != OBJECT_MOBILEfs &&
-            oType != OBJECT_MOBILEts &&
-            oType != OBJECT_MOBILEws &&
-            oType != OBJECT_MOBILEis &&
-            oType != OBJECT_MOBILErt &&
-            oType != OBJECT_MOBILErc &&
-            oType != OBJECT_MOBILErr &&
-            oType != OBJECT_MOBILErs &&
-            oType != OBJECT_MOBILEsa &&
-            oType != OBJECT_MOBILEtg &&
-            oType != OBJECT_MOBILEft &&
-            oType != OBJECT_MOBILEtt &&
-            oType != OBJECT_MOBILEwt &&
-            oType != OBJECT_MOBILEit &&
-            oType != OBJECT_MOBILEdr &&
-            oType != OBJECT_BASE     &&
-            oType != OBJECT_DERRICK  &&
-            oType != OBJECT_STATION  &&
-            oType != OBJECT_FACTORY  &&
-            oType != OBJECT_REPAIR   &&
-            oType != OBJECT_DESTROYER&&
-            oType != OBJECT_CONVERT  &&
-            oType != OBJECT_TOWER    &&
-            oType != OBJECT_RESEARCH &&
-            oType != OBJECT_RADAR    &&
-            oType != OBJECT_INFO     &&
-            oType != OBJECT_ENERGY   &&
-            oType != OBJECT_LABO     &&
-            oType != OBJECT_NUCLEAR  &&
-            oType != OBJECT_PARA     &&
-            oType != OBJECT_SAFE     &&
-            oType != OBJECT_HUSTON   &&
-            oType != OBJECT_METAL    &&
-            oType != OBJECT_POWER    &&
-            oType != OBJECT_ATOMIC   )  continue;
-
-       if ( pObj->RetTruck() != 0 )  continue;  // objet transporté ?
-
-       oPos = pObj->RetPosition(0);
-
-       shieldRadius = pObj->RetShieldRadius();
-       if ( shieldRadius > 0.0f )
-       {
-           distance = Length(oPos, iPos);
-           if ( distance <= shieldRadius )  return pObj;
-       }
-
-       if ( oType == OBJECT_BASE )
-       {
-           distance = Length(oPos, iPos);
-           if ( distance < 25.0f )  return pObj;
-       }
-
-       // Test au centre de l'objet, ce qui est nécessaire pour
-       // les objets qui n'ont pas de sphère au centre (station).
-       distance = Length(oPos, iPos)-4.0f;
-       if ( distance < 5.0f )  return pObj;
-
-       // Test avec toutes les sphères de l'objet.
-       j = 0;
-       while ( pObj->GetCrashSphere(j++, oPos, oRadius) )
-       {
-           distance = Length(oPos, iPos);
-           if ( distance <= iRadius+oRadius )
-           {
-               return pObj;
-           }
-       }
-   }
-   return 0;
-}
-
-// Chute d'un objet fret.
-
-void CPyro::FallProgress(float rTime)
-{
-   CObject*    pObj;
-   D3DVECTOR   pos;
-   BOOL        bFloor = FALSE;
-
-   if ( m_object == 0 )  return;
-
-   m_fallSpeed += rTime*50.0f;  // v2 = v1 + a*dt
-   pos = m_object->RetPosition(0);
-   pos.y -= m_fallSpeed*rTime;  // dd -= v2*dt
-
-   if ( pos.y <= m_fallFloor )  // sous le niveau du sol ?
-   {
-       pos.y = m_fallFloor;
-       bFloor = TRUE;
-   }
-   m_object->SetPosition(0, pos);
-
-   if ( m_object->RetType() == OBJECT_BULLET )
-   {
-       m_fallBulletTime += rTime;
-
-       if ( m_fallBulletTime > 0.2f || bFloor )
-       {
-           m_fallBulletTime = 0.0f;
-
-           pObj = FallSearchBeeExplo();
-           if ( pObj == 0 )
-           {
-               if ( bFloor )  // arrivé au niveau du sol ?
-               {
-                   m_object->ExploObject(EXPLO_BOUM, 0.0f);  // démarre explosion
-               }
-           }
-           else
-           {
-               if ( pObj->RetShieldRadius() > 0.0f )  // protégé par bouclier ?
-               {
-                   m_particule->CreateParticule(pos, D3DVECTOR(0.0f, 0.0f, 0.0f), FPOINT(6.0f, 6.0f), PARTIGUNDEL, 2.0f, 0.0f, 0.0f);
-                   m_sound->Play(SOUND_GUNDEL);
-
-                   DeleteObject(TRUE, TRUE);  // supprime le boulet
-               }
-               else
-               {
-                   if ( pObj->ExploObject(EXPLO_BOUM, 1.0f) )  // démarre explosion
-                   {
-                       DeleteObject(TRUE, TRUE);  // supprime le boulet
-                   }
-                   else
-                   {
-                       m_object->ExploObject(EXPLO_BOUM, 0.0f);  // démarre explosion
-                   }
-               }
-           }
-
-           if ( bFloor || pObj != 0 )
-           {
-               m_bFallEnding = TRUE;
-           }
-       }
-   }
-}
-
-// Indique si la chute est terminée.
-
-Error CPyro::FallIsEnded()
-{
-   D3DVECTOR   pos;
-
-   if ( m_bFallEnding || m_object == 0 )  return ERR_STOP;
-
-   pos = m_object->RetPosition(0);
-   if ( pos.y > m_fallFloor )  return ERR_CONTINUE;
-
-   m_sound->Play(SOUND_BOUM, pos);
-   m_object->SetBurn(FALSE);  // de nouveau utilisable
-
-   return ERR_STOP;
-}
-
